#!/usr/bin/env node
// Generated by LiveScript 1.3.1
(function(){
  var docopt, _, ref$, cat, mkdir, rm, v, uid, Promise, asyncrepl, modulePath, fs, doc, getOption, o, FILE, f, src, cwd, prepare, replaceCode, codeRegex, tmpdir, matchArray, promiseArray, promisedReplace;
  docopt = require('docopt').docopt;
  _ = require('lodash');
  ref$ = require('shelljs'), cat = ref$.cat, mkdir = ref$.mkdir, rm = ref$.rm;
  v = require('verbal-expressions');
  uid = require('uid');
  Promise = require('bluebird');
  asyncrepl = require('async-replace');
  modulePath = "/usr/local/share/npm/lib/node_modules/";
  fs = require('fs');
  doc = "Usage:\n    exemd FILE [ -p | --pdf ] [ -r | --pure ] \n    exemd -h | --help \n\nOptions:\n    -p, --pdf   Generate a pdf\n    -r, --raw   Unfold and execute blocks, generate raw markdown\n    -h, --help  \n\nArguments: \n    FILE       markdown file name.\n";
  getOption = function(a, b, def, o){
    if (!o[a] && !o[b]) {
      return def;
    } else {
      return o[b];
    }
  };
  o = docopt(doc);
  FILE = o['FILE'];
  f = cat(FILE);
  src = __dirname;
  cwd = process.cwd();
  prepare = function(){
    var dirname;
    dirname = cwd + "/tmp" + uid(7);
    mkdir(dirname);
    return dirname;
  };
  replaceCode = curry$(function(tmpdir, m, lang, params, code, offset, string, done){
    var process, opts, block;
    process = require(modulePath + "exemd-" + lang).process;
    opts = {};
    opts.targetMode = 'html';
    opts.params = params;
    opts.orig = m;
    opts.tmpdir = tmpdir;
    block = code;
    return process(block, opts).then(function(it){
      return done(null, it);
    }, function(it){
      return done(it, null);
    });
  });
  codeRegex = v().then("```").anythingBut("{").then("{").beginCapture().word().endCapture().beginCapture().anythingBut("}").endCapture().then("}").beginCapture().anythingBut("```").endCapture().then("```");
  tmpdir = prepare();
  matchArray = [];
  promiseArray = [];
  promisedReplace = curry$(function(regex, myAsyncReplace, string){
    return new Promise(function(res, rej){
      return asyncrepl(string, regex, myAsyncReplace, function(err, result){
        if (err) {
          return rej(err);
        } else {
          return res(result);
        }
      });
    });
  });
  promisedReplace(codeRegex, replaceCode(tmpdir), f).then(function(it){
    return console.log(it);
  }).done(function(){
    console.log("done!");
    return rm('-rf', tmpdir);
  });
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
