// Generated by LiveScript 1.3.1
(function(){
  var docopt, _, ref$, cat, mkdir, rm, exec, v, uid, Promise, asyncrepl, modulePath, fs, src, cwd, prepare, replaceCode, codeRegex, matchArray, promiseArray, par, promiseWhile, promisedReplace, _module;
  docopt = require('docopt').docopt;
  _ = require('lodash');
  ref$ = require('shelljs'), cat = ref$.cat, mkdir = ref$.mkdir, rm = ref$.rm, exec = ref$.exec;
  v = require('verbal-expressions');
  uid = require('uid');
  Promise = require('bluebird');
  asyncrepl = require('async-replace');
  modulePath = "";
  fs = require('fs');
  src = __dirname;
  cwd = process.cwd();
  prepare = function(){
    var dirname;
    dirname = cwd + "/tmp" + uid(7);
    mkdir(dirname);
    return dirname;
  };
  replaceCode = curry$(function(tmpdir, targetMode, m, lang, params, code, offset, string, done){
    var process, opts, block;
    process = require(modulePath + "exemd-" + lang).process;
    opts = {};
    opts.targetMode = targetMode;
    opts.params = params;
    opts.orig = m;
    opts.tmpdir = tmpdir;
    block = code;
    return process(block, opts).then(function(it){
      return done(null, it);
    }, function(it){
      return done(it, null);
    });
  });
  codeRegex = v().then("```").anythingBut("{").then("{").beginCapture().word().endCapture().anythingBut("!").then("!").beginCapture().anythingBut("}").endCapture().then("}").beginCapture().anythingBut("```").endCapture().then("```");
  matchArray = [];
  promiseArray = [];
  par = curry$(function(regex, myAsyncReplace, string){
    return (function(lstring){
      return new Promise(function(res, rej){
        return asyncrepl(lstring, regex, myAsyncReplace, function(err, result){
          if (lstring === result) {
            return rej(lstring);
          } else {
            return res(result);
          }
        });
      });
    }.call(this, string));
  });
  promiseWhile = function(init, action){
    var val;
    val = init;
    return new Promise(function(res, rej){
      var loop_;
      loop_ = function(it){
        return action(it).delay(1).then(loop_).caught(res);
      };
      return process.nextTick(function(){
        return loop_(init);
      });
    });
  };
  promisedReplace = function(regex, myAsyncReplace, string){
    return promiseWhile(string, par(regex, myAsyncReplace));
  };
  _module = function(){
    var process, iface;
    process = function(targetMode, text){
      var tmpdir, convert;
      tmpdir = prepare();
      convert = function(it){
        var tmpMarkdown;
        if (targetMode === 'raw') {
          return it;
        } else {
          if (targetMode === 'html') {
            tmpMarkdown = tmpdir + "/" + uid(7) + ".md";
            it.to(tmpMarkdown);
            return new Promise(function(res, rej){
              return exec("pandoc -s " + tmpMarkdown, {
                async: true,
                silent: true
              }, function(code, output){
                rm('-rf', tmpdir);
                if (!code) {
                  return res(output);
                } else {
                  return rej(output);
                }
              });
            });
          } else {
            return rej('unsupported');
          }
        }
      };
      return promisedReplace(codeRegex, replaceCode(tmpdir, targetMode), text).then(convert, function(it){
        rm('-rf', tmpdir);
        throw it;
      });
    };
    return iface = {
      process: process
    };
  };
  module.exports = _module();
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
