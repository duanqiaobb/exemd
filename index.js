// Generated by LiveScript 1.3.1
(function(){
  var docopt, _, ref$, cat, mkdir, rm, exec, v, uid, Promise, asyncrepl, debug, $, modulePath, fs, src, cwd, prepare, getBlock, getHeader, replaceHandlerGen, codeBlock, codeRegex, matchArray, promiseArray, par, promiseWhile, promisedReplace, _module;
  docopt = require('docopt').docopt;
  _ = require('lodash');
  ref$ = require('shelljs'), cat = ref$.cat, mkdir = ref$.mkdir, rm = ref$.rm, exec = ref$.exec;
  v = require('verbal-expressions');
  uid = require('uid');
  Promise = require('bluebird');
  asyncrepl = require('async-replace');
  debug = require('debug')('exemd');
  $ = require('underscore.string');
  uid = require("uid");
  modulePath = "";
  fs = require('fs');
  src = __dirname;
  cwd = process.cwd();
  prepare = function(){
    var dirname;
    dirname = cwd + "/tmp" + uid(7);
    mkdir(dirname);
    return dirname;
  };
  getBlock = function(string){
    var block, mtch;
    block = v().then("```").anythingBut("}").then("}").beginCapture().anythingBut("```").endCapture().then("```");
    mtch = block.exec(string);
    if (mtch != null) {
      return {
        block: mtch[1]
      };
    } else {
      return undefined;
    }
  };
  getHeader = function(string){
    var header, mtch;
    header = v().searchOneLine().then("```").anythingBut("{").then("{").beginCapture().word().endCapture().anythingBut("!").then("!").beginCapture().anythingBut("}").endCapture().then("}");
    mtch = header.exec(string);
    if (mtch != null) {
      return {
        language: mtch[1],
        params: mtch[2]
      };
    } else {
      return undefined;
    }
  };
  replaceHandlerGen = curry$(function(tmpdir, targetMode, codeBlock, offset, string, done){
    var process, language, params, block, codeBlockRes, blockRes, e, opts, pluginTemplate;
    process = {};
    language = "";
    params = {};
    block = "";
    codeBlockRes = getHeader(codeBlock);
    debug(codeBlock);
    debug(codeBlockRes);
    if (codeBlockRes == null) {
      debug("Bailing out..");
      done(null, codeBlock);
      return;
    } else {
      language = codeBlockRes.language, params = codeBlockRes.params;
    }
    blockRes = getBlock(codeBlock);
    if (blockRes == null) {
      done(null, codeBlock);
      return;
    } else {
      block = blockRes.block;
    }
    try {
      debug("Trying language " + language);
      debug("Original code " + block);
      process = require(modulePath + "exemd-" + language).process;
    } catch (e$) {
      e = e$;
      debug("uff..: " + e);
      done(codeBlock);
      return;
    }
    opts = {};
    opts.targetMode = targetMode;
    opts.params = params;
    opts.orig = codeBlock;
    opts.tmpdir = tmpdir;
    pluginTemplate = function(targets, block, opts){
      var params;
      params == null && (params = opts.params);
      params == null && (params = '');
      return new Promise(function(resolve, preject){
        var tempFile, cmd;
        debug("Running template");
        debug(targets);
        debug(opts.targetMode);
        if (targets[opts.targetMode] != null) {
          tempFile = uid(7);
          debug("Target mode: " + opts.targetMode);
          debug(targets);
          cmd = targets[opts.targetMode].cmd(block, tempFile, opts.tmpdir, params);
          debug(cmd);
          return exec(cmd, {
            async: true,
            silent: true
          }, function(code, output){
            output = targets[opts.targetMode].output(tempFile, opts.tmpdir, output);
            debug(output);
            if (!code) {
              return resolve(output);
            } else {
              return resolve("```" + block + "```");
            }
          });
        } else {
          return resolve("```" + block + "```");
        }
      });
    };
    opts.pluginTemplate = pluginTemplate;
    debug("Invoking process");
    debug(opts);
    return process(block, opts).then(function(it){
      return done(null, it);
    }, function(it){
      return done(it, null);
    });
  });
  codeBlock = v().then("```").anythingBut("```").then("```");
  codeRegex = codeBlock;
  matchArray = [];
  promiseArray = [];
  par = curry$(function(regex, replaceHandler, string){
    return (function(lstring){
      return new Promise(function(res, rej){
        return asyncrepl(lstring, regex, replaceHandler, function(err, result){
          if (lstring === result) {
            return rej(lstring);
          } else {
            return res(result);
          }
        });
      });
    }.call(this, string));
  });
  promiseWhile = function(init, action){
    var val;
    val = init;
    return new Promise(function(res, rej){
      var loop_;
      loop_ = function(it){
        return action(it).delay(1).then(loop_).caught(res);
      };
      return process.nextTick(function(){
        return loop_(init);
      });
    });
  };
  promisedReplace = function(regex, replaceHandler, string){
    return promiseWhile(string, par(regex, replaceHandler));
  };
  _module = function(){
    var process, iface;
    process = function(targetMode, text){
      var ref$, finalSrc, diaMode, tmpdir, convert;
      ref$ = $.words(targetMode, ','), finalSrc = ref$[0], diaMode = ref$[1];
      diaMode == null && (diaMode = 'default');
      finalSrc == null && (finalSrc = 'html');
      tmpdir = prepare();
      convert = function(it){
        var tmpMarkdown;
        if (finalSrc === 'raw') {
          rm('-rf', tmpdir);
          return it;
        } else {
          if (finalSrc === 'html') {
            tmpMarkdown = tmpdir + "/" + uid(7) + ".md";
            it.to(tmpMarkdown);
            return new Promise(function(res, rej){
              return exec("pandoc -s " + tmpMarkdown, {
                async: true,
                silent: true
              }, function(code, output){
                rm('-rf', tmpdir);
                if (!code) {
                  return res(output);
                } else {
                  return rej(output);
                }
              });
            });
          } else {
            throw "unsupported " + finalSrc;
          }
        }
      };
      return promisedReplace(codeRegex, replaceHandlerGen(tmpdir, diaMode), text).then(convert, function(it){
        rm('-rf', tmpdir);
        throw it;
      });
    };
    return iface = {
      process: process
    };
  };
  module.exports = _module();
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
